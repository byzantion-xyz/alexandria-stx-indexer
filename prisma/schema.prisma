generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider          = "postgresql"
  url               = env("DATABASE_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}

model SmartContract {
  id                   Int    @id @default(autoincrement())
  contract_key         String @unique
  name                 String
  scanned_transactions Int    @default(0)
  type                 String

  chain    Chain @relation(fields: [chain_id], references: [id])
  chain_id Int

  commission               Commission?
  smart_contract_functions SmartContractFunction[]
  nft_metas                NftMeta[]

  created_at      DateTime        @default(now())
  updated_at      DateTime        @updatedAt
  collection_bids CollectionBid[]
  actions         Action[]
}

model SmartContractFunction {
  id            Int    @id @default(autoincrement())
  name          String
  function_name String
  args          Json

  smart_contract    SmartContract @relation(fields: [smart_contract_id], references: [id])
  smart_contract_id Int

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt
}

model Commission {
  id             Int     @id @default(autoincrement())
  commission_key String  @unique
  custodial      Boolean
  amount         Int?

  smart_contract    SmartContract @relation(fields: [smart_contract_id], references: [id])
  smart_contract_id Int           @unique

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt
}

model Chain {
  id   Int    @id @default(autoincrement())
  name String

  smart_contracts SmartContract[]
  nft_metas       NftMeta[]

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt
}

model Collection {
  id              Int     @id @default(autoincrement())
  asset_name      String
  collection_size Int?
  description     String?
  external_url    String?
  volume          Int     @default(0)
  floor           Int     @default(0)
  cover_image     String?
  trending        Boolean @default(false)
  title           String?
  frozen          Boolean @default(false)

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  metas   NftMeta[]
  actions Action[]
}

model CollectionBid {
  id Int @id @default(autoincrement())

  token_id      String
  token_id_list String[]

  nonce              Int
  bid_contract_nonce String
  bid_price          String
  bid_buyer          String
  bid_seller         String
  status             CollectionBidStatus @default(active)

  pending_txs String[]
  pending_tx  String

  tx_id        String
  block_height Int
  match_tx_id  String
  cancel_tx_id String
  bid_type     BidType

  smart_contract    SmartContract @relation(fields: [smart_contract_id], references: [id])
  smart_contract_id Int

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt
}

model NftMeta {
  id         Int     @id @default(autoincrement())
  uuid       String  @default(uuid())
  name       String
  namespace  String?
  image      String
  token_id   Int
  rarity     Int?
  ranking    Int
  burned     Boolean @default(false)
  asset_name String?
  grouping   String?
  spec       String?

  collection    Collection @relation(fields: [collection_id], references: [id])
  collection_id Int

  chain    Chain @relation(fields: [chain_id], references: [id])
  chain_id Int

  smart_contract    SmartContract @relation(fields: [smart_contract_id], references: [id])
  smart_contract_id Int

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  nft_meta_bns NftMetaBns?
  actions      Action[]
}

model NftMetaBns {
  id        Int    @id @default(autoincrement())
  name      String
  namespace String

  meta    NftMeta @relation(fields: [meta_id], references: [id])
  meta_id Int     @unique
}

model Action {
  id Int @id @default(autoincrement())

  action        ActionName
  bid_attribute Json?
  list_price    Int?
  seller        String?
  buyer         String?
  bid_price     Int
  block_height  Int
  tx_index      Int
  block_time    DateTime
  tx_id         String
  segment       Boolean    @default(false)
  market_name   String?
  nonce         Int?
  units         Int?

  smart_contract    SmartContract? @relation(fields: [smart_contract_id], references: [id])
  smart_contract_id Int?

  nft_meta    NftMeta? @relation(fields: [nft_meta_id], references: [id])
  nft_meta_id Int?

  collection    Collection? @relation(fields: [collection_id], references: [id])
  collection_id Int?
}

enum CollectionBidStatus {
  active
  pending
  cancelled
  matched
}

enum BidType {
  collection
  attribute
  solo
}

enum ActionName {
  list
  unlist
  buy
}
