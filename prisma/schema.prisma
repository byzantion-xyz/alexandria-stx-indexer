generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider          = "postgresql"
  url               = env("DATABASE_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}

model SmartContract {
  id                       String                                @id @default(uuid()) @db.Uuid
  contract_key             String                                @unique
  spec                     String?
  name                     String
  scanned_transactions     Int                                   @default(0)
  type                     SmartContractType
  chain_id                 String                                @db.Uuid
  created_at               DateTime                              @default(now())
  updated_at               DateTime                              @updatedAt
  asset_name               String?
  frozen                   Boolean                               @default(false)
  json_meta                Json?
  chain                    Chain                                 @relation(fields: [chain_id], references: [id])
  collection               Collection?
  actions                  Action[]
  collection_bids          CollectionBid[]
  commission               Commission?
  nft_metas                NftMeta[]
  nft_state                NftState[]
  smart_contract_functions SmartContractFunction[]
  discord_server_channels  SmartContractOnDiscordServerChannel[]
  marketplace_actions      Action[]                              @relation("marketplace_actions")

  smart_contract_scrape_id String?              @unique @db.Uuid
  smart_contract_scrape    SmartContractScrape? @relation(fields: [smart_contract_scrape_id], references: [id])

  @@map("smart_contract")
}

model SmartContractFunction {
  id                String        @id @default(uuid()) @db.Uuid
  name              String
  function_name     String
  args              Json
  smart_contract_id String        @db.Uuid
  created_at        DateTime      @default(now())
  updated_at        DateTime      @updatedAt
  smart_contract    SmartContract @relation(fields: [smart_contract_id], references: [id])

  @@unique([function_name, smart_contract_id])
  @@map("smart_contract_function")
}

model SmartContractScrape {
  id String @id @default(uuid()) @db.Uuid

  stage             SmartContractScrapeStage?   @default(getting_tokens_from_chain)
  outcome           SmartContractScrapeOutcome?
  outcome_msg       String?
  error             Json?
  smart_contract    SmartContract?
  smart_contract_id String                      @unique @db.Uuid

  @@map("smart_contract_scrape")
}

model Commission {
  id                String        @id @default(uuid()) @db.Uuid
  commission_key    String        @unique
  custodial         Boolean
  amount            Int?
  smart_contract_id String        @unique @db.Uuid
  created_at        DateTime      @default(now())
  updated_at        DateTime      @updatedAt
  smart_contract    SmartContract @relation(fields: [smart_contract_id], references: [id])

  @@map("commission")
}

model Chain {
  id              String          @id @default(uuid()) @db.Uuid
  name            String
  created_at      DateTime        @default(now())
  updated_at      DateTime        @updatedAt
  coin            String?
  symbol          String          @unique
  nft_metas       NftMeta[]
  smart_contracts SmartContract[]

  @@map("chain")
}

model Collection {
  id                String                @id @default(uuid()) @db.Uuid
  collection_size   Int?
  description       String?
  external_url      String?
  volume            Int                   @default(0)
  floor             Int                   @default(0)
  cover_image       String?
  trending          Boolean               @default(false)
  title             String?
  created_at        DateTime              @default(now())
  updated_at        DateTime              @updatedAt
  slug              String?               @unique
  actions           Action[]
  attributes        CollectionAttribute[]
  metas             NftMeta[]
  smart_contract_id String?               @unique @db.Uuid
  smart_contract    SmartContract?        @relation(fields: [smart_contract_id], references: [id])

  @@map("collection")
}

model CollectionAttribute {
  id String @id @default(uuid()) @db.Uuid

  trait_type String
  value      String
  rarity     Float
  total      Int

  collection    Collection @relation(fields: [collection_id], references: [id])
  collection_id String     @db.Uuid
  created_at    DateTime   @default(now())
  updated_at    DateTime   @updatedAt

  @@unique([collection_id, trait_type, value])
  @@map("collection_attribute")
}

model CollectionBid {
  id                 String              @id @default(uuid()) @db.Uuid
  token_id           String
  token_id_list      String[]
  nonce              Int
  bid_contract_nonce String
  bid_buyer          String
  bid_seller         String
  status             CollectionBidStatus @default(active)
  pending_txs        String[]
  pending_tx         String
  tx_id              String
  block_height       BigInt
  match_tx_id        String
  cancel_tx_id       String
  bid_type           BidType
  smart_contract_id  String              @db.Uuid
  created_at         DateTime            @default(now())
  updated_at         DateTime            @updatedAt
  bid_price          BigInt
  smart_contract     SmartContract       @relation(fields: [smart_contract_id], references: [id])

  @@map("collection_bid")
}

model NftMeta {
  id                String             @id @default(uuid()) @db.Uuid
  uuid              String             @default(uuid())
  name              String
  namespace         String?
  image             String
  token_id          String
  rarity            Float?
  ranking           Int
  asset_name        String?
  grouping          String?
  collection_id     String?            @db.Uuid
  chain_id          String             @db.Uuid
  smart_contract_id String             @db.Uuid
  created_at        DateTime           @default(now())
  updated_at        DateTime           @updatedAt
  json_meta         Json?
  chain             Chain              @relation(fields: [chain_id], references: [id])
  collection        Collection?        @relation(fields: [collection_id], references: [id])
  smart_contract    SmartContract      @relation(fields: [smart_contract_id], references: [id])
  actions           Action[]
  attributes        NftMetaAttribute[]
  nft_meta_bns      NftMetaBns?
  nft_state         NftState?

  @@unique([smart_contract_id, token_id])
  @@map("nft_meta")
}

model NftMetaAttribute {
  id         String   @id @default(uuid()) @db.Uuid
  trait_type String
  value      String
  rarity     Float    @default(0)
  score      Float    @default(0)
  meta_id    String   @db.Uuid
  created_at DateTime @default(now())
  updated_at DateTime @updatedAt
  meta       NftMeta  @relation(fields: [meta_id], references: [id])

  @@unique([trait_type, value, meta_id])
  @@map("nft_meta_attribute")
}

model NftState {
  id                  String         @id @default(uuid()) @db.Uuid
  burned              Boolean        @default(false)
  minted              Boolean        @default(false)
  mint_tx             String?
  listed              Boolean        @default(false)
  list_price          Decimal?       @db.Decimal(32, 0)
  list_seller         String?
  list_block_height   BigInt?
  list_tx_index       BigInt?
  asking              Boolean        @default(false)
  asking_price        BigInt?
  asking_block_height BigInt?
  asking_tx_index     BigInt?
  asking_seller       String?
  bid                 Boolean        @default(false)
  bid_price           BigInt?
  bid_buyer           String?
  bid_contract        String?
  bid_block_height    BigInt?
  bid_tx_index        BigInt?
  staked              Boolean        @default(false)
  staking_contract    String?
  staked_owner        String?
  staked_block_height BigInt?
  staked_tx_index     BigInt?
  meta_id             String         @unique @db.Uuid
  updated_at          DateTime       @updatedAt
  list_contract_id    String?        @db.Uuid
  list_contract       SmartContract? @relation(fields: [list_contract_id], references: [id])
  meta                NftMeta        @relation(fields: [meta_id], references: [id])

  @@map("nft_state")
}

model NftMetaBns {
  id        String  @id @default(uuid()) @db.Uuid
  name      String
  namespace String
  meta_id   String  @unique @db.Uuid
  meta      NftMeta @relation(fields: [meta_id], references: [id])

  @@map("nft_meta_bns")
}

model Action {
  id                            String         @id @default(uuid()) @db.Uuid
  action                        ActionName
  bid_attribute                 Json?
  list_price                    Decimal?       @db.Decimal(32, 0)
  seller                        String?
  buyer                         String?
  bid_price                     BigInt?
  block_height                  BigInt
  tx_index                      BigInt
  block_time                    DateTime
  tx_id                         String
  segment                       Boolean        @default(false)
  market_name                   String?
  nonce                         BigInt?
  units                         Int?
  smart_contract_id             String?        @db.Uuid
  marketplace_smart_contract_id String?        @db.Uuid
  nft_meta_id                   String?        @db.Uuid
  collection_id                 String?        @db.Uuid
  collection                    Collection?    @relation(fields: [collection_id], references: [id])
  nft_meta                      NftMeta?       @relation(fields: [nft_meta_id], references: [id])
  smart_contract                SmartContract? @relation(fields: [smart_contract_id], references: [id])
  marketplace_smart_contract    SmartContract? @relation(fields: [marketplace_smart_contract_id], references: [id], name: "marketplace_actions")

  @@map("action")
}

model DiscordServer {
  id                      String                 @id @default(uuid()) @db.Uuid
  server_id               BigInt
  server_name             String
  active                  Boolean                @default(false)
  discord_server_channels DiscordServerChannel[]

  @@map("discord_server")
}

model DiscordServerChannel {
  id                String                                @id @default(uuid()) @db.Uuid
  channel_id        BigInt
  name              String
  purpose           DiscordChannelType
  discord_server    DiscordServer                         @relation(fields: [discord_server_id], references: [id])
  discord_server_id String                                @db.Uuid
  smart_contracts   SmartContractOnDiscordServerChannel[]

  @@map("discord_server_channel")
}

model SmartContractOnDiscordServerChannel {
  smart_contract            SmartContract        @relation(fields: [smart_contract_id], references: [id])
  smart_contract_id         String               @db.Uuid
  discord_server_channel    DiscordServerChannel @relation(fields: [discord_server_channel_id], references: [id])
  discord_server_channel_id String               @db.Uuid

  updated_at DateTime @updatedAt
  created_at DateTime @default(now())

  @@unique([smart_contract_id, discord_server_channel_id])
  @@map("smart_contract_on_discord_server_channel")
}

enum CollectionBidStatus {
  active
  pending
  cancelled
  matched
}

enum BidType {
  collection
  attribute
  solo
}

enum ActionName {
  list
  unlist
  buy
}

enum SmartContractType {
  non_fungible_tokens
  marketplace
  staking
  fungible_tokens
  bridge
}

enum DiscordChannelType {
  sales
  listings
  bids
}

enum SmartContractScrapeStage {
  getting_tokens_from_chain
  pinning
  loading_nft_metas
  updating_rarities
  creating_collection_attributes
  done
}

enum SmartContractScrapeOutcome {
  succeeded
  failed
  skipped
  blacklisted
}
