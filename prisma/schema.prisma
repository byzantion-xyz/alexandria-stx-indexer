generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider          = "postgresql"
  url               = env("DATABASE_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}

model SmartContract {
  id                   String            @id @default(uuid()) @db.Uuid
  contract_key         String            @unique
  name                 String
  scanned_transactions Int               @default(0)
  type                 SmartContractType
  asset_name           String?
  frozen               Boolean           @default(false)

  chain    Chain  @relation(fields: [chain_id], references: [id])
  chain_id String @db.Uuid

  commission               Commission?
  smart_contract_functions SmartContractFunction[]
  nft_metas                NftMeta[]

  created_at      DateTime        @default(now())
  updated_at      DateTime        @updatedAt
  collection_bids CollectionBid[]
  actions         Action[]

  nft_state NftState[]

  @@map("smart_contract")
}

model SmartContractFunction {
  id            String @id @default(uuid()) @db.Uuid
  name          String
  function_name String
  args          Json

  smart_contract    SmartContract @relation(fields: [smart_contract_id], references: [id])
  smart_contract_id String        @db.Uuid

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt


  @@unique([function_name, smart_contract_id])
  @@map("smart_contract_function")
}

model Commission {
  id             String  @id @default(uuid()) @db.Uuid
  commission_key String  @unique
  custodial      Boolean
  amount         Int?

  smart_contract    SmartContract @relation(fields: [smart_contract_id], references: [id])
  smart_contract_id String        @unique @db.Uuid

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@map("commission")
}

model Chain {
  id     String  @id @default(uuid()) @db.Uuid
  name   String
  symbol String  @unique
  coin   String?

  smart_contracts SmartContract[]
  nft_metas       NftMeta[]

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@map("chain")
}

model Collection {
  id              String  @id @default(uuid()) @db.Uuid
  collection_size Int?
  description     String?
  external_url    String?
  volume          Int     @default(0)
  floor           Int     @default(0)
  cover_image     String?
  trending        Boolean @default(false)
  title           String?
  slug            String? @unique

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  metas      NftMeta[]
  actions    Action[]
  attributes CollectionAttribute[]

  @@map("collection")
}

model CollectionAttribute {
  id String @id @default(uuid()) @db.Uuid

  name   String
  value  String
  rarity Float
  total  Int

  collection    Collection @relation(fields: [collection_id], references: [id])
  collection_id String     @db.Uuid

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@map("collection_attribute")
}

model CollectionBid {
  id String @id @default(uuid()) @db.Uuid

  token_id      String
  token_id_list String[]

  nonce              Int
  bid_contract_nonce String
  bid_price          BigInt
  bid_buyer          String
  bid_seller         String
  status             CollectionBidStatus @default(active)

  pending_txs String[]
  pending_tx  String

  tx_id        String
  block_height BigInt
  match_tx_id  String
  cancel_tx_id String
  bid_type     BidType

  smart_contract    SmartContract @relation(fields: [smart_contract_id], references: [id])
  smart_contract_id String        @db.Uuid

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@map("collection_bid")
}

model NftMeta {
  id String @id @default(uuid()) @db.Uuid

  uuid       String  @default(uuid())
  name       String
  namespace  String?
  image      String
  token_id   String
  rarity     Float?
  ranking    Int
  asset_name String?
  grouping   String?
  spec       String?

  collection    Collection? @relation(fields: [collection_id], references: [id])
  collection_id String?     @db.Uuid

  chain    Chain  @relation(fields: [chain_id], references: [id])
  chain_id String @db.Uuid

  smart_contract    SmartContract @relation(fields: [smart_contract_id], references: [id])
  smart_contract_id String        @db.Uuid

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  nft_meta_bns NftMetaBns?
  nft_state    NftState?
  actions      Action[]
  attributes   NftMetaAttribute[]


  @@unique([smart_contract_id, token_id])
  @@map("nft_meta")
}

model NftMetaAttribute {
  id String @id @default(uuid()) @db.Uuid

  trait_type  String
  trait_group String?
  value       String
  rarity      Float   @default(0)
  sequence    String?
  score       Float   @default(0)

  meta    NftMeta @relation(fields: [meta_id], references: [id])
  meta_id String  @db.Uuid

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@map("nft_meta_attribute")
}

model NftState {
  id String @id @default(uuid()) @db.Uuid

  burned Boolean @default(false)

  minted  Boolean @default(false)
  mint_tx String

  listed            Boolean        @default(false)
  list_price        BigInt
  list_seller       String
  list_block_height BigInt
  list_tx_index     BigInt
  list_contract     SmartContract? @relation(fields: [list_contract_id], references: [id])
  list_contract_id  String         @db.Uuid

  asking              Boolean @default(false)
  asking_price        BigInt
  asking_block_height BigInt
  asking_tx_index     BigInt
  asking_seller       String

  bid              Boolean @default(false)
  bid_price        BigInt
  bid_buyer        String
  bid_contract     String
  bid_block_height BigInt
  bid_tx_index     BigInt

  staked              Boolean @default(false)
  staking_contract    String
  staked_owner        String
  staked_block_height BigInt
  staked_tx_index     BigInt

  meta    NftMeta @relation(fields: [meta_id], references: [id])
  meta_id String  @unique @db.Uuid

  updated_at DateTime @updatedAt

  @@map("nft_state")
}

model NftMetaBns {
  id        String @id @default(uuid()) @db.Uuid
  name      String
  namespace String

  meta    NftMeta @relation(fields: [meta_id], references: [id])
  meta_id String  @unique @db.Uuid

  @@map("nft_meta_bns")
}

model Action {
  id String @id @default(uuid()) @db.Uuid

  action        ActionName
  bid_attribute Json?
  list_price    BigInt?
  seller        String?
  buyer         String?
  bid_price     BigInt?
  block_height  BigInt
  tx_index      BigInt
  block_time    DateTime
  tx_id         String
  segment       Boolean    @default(false)
  market_name   String?
  nonce         Int?
  units         Int?

  smart_contract    SmartContract? @relation(fields: [smart_contract_id], references: [id])
  smart_contract_id String?        @db.Uuid

  nft_meta    NftMeta? @relation(fields: [nft_meta_id], references: [id])
  nft_meta_id String?  @db.Uuid

  collection    Collection? @relation(fields: [collection_id], references: [id])
  collection_id String?     @db.Uuid

  @@map("action")
}

enum CollectionBidStatus {
  active
  pending
  cancelled
  matched
}

enum BidType {
  collection
  attribute
  solo
}

enum ActionName {
  list
  unlist
  buy
}

enum SmartContractType {
  non_fungible_tokens
  marketplace
  staking
  fungible_tokens
  bridge
}
