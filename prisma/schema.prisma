generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider          = "postgresql"
  url               = env("DATABASE_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}

model SmartContract {
  id                       String                  @id @default(uuid()) @db.Uuid
  contract_key             String                  @unique
  spec                     String?
  name                     String?
  scanned_transactions     Int                     @default(0)
  type                     SmartContractType
  chain_id                 String                  @db.Uuid
  created_at               DateTime                @default(now())
  updated_at               DateTime                @updatedAt
  asset_name               String?
  frozen                   Boolean                 @default(false)
  json_meta                Json?
  base_marketplace_uri     String?
  token_uri                String?
  collection_uri           String?
  chain                    Chain                   @relation(fields: [chain_id], references: [id])
  collections              Collection[]
  actions                  Action[]
  collection_bids          CollectionBid[]
  commission               Commission?
  nft_metas                NftMeta[]
  nft_state                NftState[]
  smart_contract_functions SmartContractFunction[]
  marketplace_actions      Action[]                @relation("marketplace_actions")

  @@map("smart_contract")
}

model SmartContractFunction {
  id                String        @id @default(uuid()) @db.Uuid
  name              String
  function_name     String
  args              Json
  smart_contract_id String        @db.Uuid
  created_at        DateTime      @default(now())
  updated_at        DateTime      @updatedAt
  smart_contract    SmartContract @relation(fields: [smart_contract_id], references: [id])

  @@unique([function_name, smart_contract_id])
  @@map("smart_contract_function")
}

model Commission {
  id                String        @id @default(uuid()) @db.Uuid
  commission_key    String        @unique
  custodial         Boolean
  amount            Int?
  smart_contract_id String        @unique @db.Uuid
  created_at        DateTime      @default(now())
  updated_at        DateTime      @updatedAt
  smart_contract    SmartContract @relation(fields: [smart_contract_id], references: [id])

  @@map("commission")
}

model Chain {
  id              String          @id @default(uuid()) @db.Uuid
  name            String
  created_at      DateTime        @default(now())
  updated_at      DateTime        @updatedAt
  coin            String?
  symbol          String          @unique
  nft_metas       NftMeta[]
  smart_contracts SmartContract[]

  @@map("chain")
}

model Collection {
  id                      String                             @id @default(uuid()) @db.Uuid
  collection_size         Int?
  description             String?
  external_url            String?
  volume                  Int                                @default(0)
  floor                   Int                                @default(0)
  cover_image             String?
  trending                Boolean                            @default(false)
  title                   String?
  created_at              DateTime                           @default(now())
  updated_at              DateTime                           @updatedAt
  slug                    String?                            @unique
  actions                 Action[]
  attributes              CollectionAttribute[]
  metas                   NftMeta[]
  smart_contract_id       String?                            @db.Uuid
  smart_contract          SmartContract?                     @relation(fields: [smart_contract_id], references: [id])
  collection_scrape_id    String?                            @unique @db.Uuid
  collection_scrape       CollectionScrape?                  @relation(fields: [collection_scrape_id], references: [id])
  creator                 CollectionCreator?
  discord_server_channels CollectionOnDiscordServerChannel[]

  @@map("collection")
}

model CollectionAttribute {
  id String @id @default(uuid()) @db.Uuid

  trait_type String
  value      String
  rarity     Float
  total      Int

  collection    Collection @relation(fields: [collection_id], references: [id])
  collection_id String     @db.Uuid
  created_at    DateTime   @default(now())
  updated_at    DateTime   @updatedAt

  @@unique([collection_id, trait_type, value])
  @@map("collection_attribute")
}

model CollectionBid {
  id                 String              @id @default(uuid()) @db.Uuid
  token_id           String
  token_id_list      String[]
  nonce              Int
  bid_contract_nonce String
  bid_buyer          String
  bid_seller         String
  status             CollectionBidStatus @default(active)
  pending_txs        String[]
  pending_tx         String
  tx_id              String
  block_height       BigInt
  match_tx_id        String
  cancel_tx_id       String
  bid_type           BidType
  smart_contract_id  String              @db.Uuid
  created_at         DateTime            @default(now())
  updated_at         DateTime            @updatedAt
  bid_price          BigInt
  smart_contract     SmartContract       @relation(fields: [smart_contract_id], references: [id])

  @@map("collection_bid")
}

model CollectionCreator {
  id        String  @id @default(uuid()) @db.Uuid
  wallet_id String
  name      String?
  bio       String?
  twitter   String?
  discord   String?
  website   String?

  collection    Collection @relation(fields: [collection_id], references: [id])
  collection_id String     @unique @db.Uuid

  @@map("collection_creator")
}

model CollectionScrape {
  id String @id @default(uuid()) @db.Uuid

  stage         CollectionScrapeStage?   @default(getting_tokens)
  outcome       CollectionScrapeOutcome?
  outcome_msg   String?
  error         Json?
  collection    Collection?
  collection_id String                   @unique @db.Uuid
  attempts      Int                      @default(0)

  @@map("collection_scrape")
}

model NftMeta {
  id                String             @id @default(uuid()) @db.Uuid
  uuid              String             @default(uuid())
  name              String
  namespace         String?
  image             String
  token_id          String
  rarity            Float?
  ranking           Int
  asset_name        String?
  grouping          String?
  collection_id     String?            @db.Uuid
  chain_id          String             @db.Uuid
  smart_contract_id String             @db.Uuid
  created_at        DateTime           @default(now())
  updated_at        DateTime           @updatedAt
  json_meta         Json?
  chain             Chain              @relation(fields: [chain_id], references: [id])
  collection        Collection?        @relation(fields: [collection_id], references: [id])
  smart_contract    SmartContract      @relation(fields: [smart_contract_id], references: [id])
  actions           Action[]
  attributes        NftMetaAttribute[]
  nft_meta_bns      NftMetaBns?
  nft_state         NftState?

  @@unique([collection_id, token_id])
  @@map("nft_meta")
}

model NftMetaAttribute {
  id         String   @id @default(uuid()) @db.Uuid
  trait_type String
  value      String
  rarity     Float    @default(0)
  score      Float    @default(0)
  meta_id    String   @db.Uuid
  created_at DateTime @default(now())
  updated_at DateTime @updatedAt
  meta       NftMeta  @relation(fields: [meta_id], references: [id])

  @@unique([trait_type, value, meta_id])
  @@map("nft_meta_attribute")
}

model NftState {
  id                  String         @id @default(uuid()) @db.Uuid
  burned              Boolean        @default(false)
  minted              Boolean        @default(false)
  mint_tx             String?
  listed              Boolean        @default(false)
  list_price          Decimal?       @db.Decimal(32, 0)
  list_seller         String?
  list_block_height   BigInt?
  list_tx_index       BigInt?
  asking              Boolean        @default(false)
  asking_price        BigInt?
  asking_block_height BigInt?
  asking_tx_index     BigInt?
  asking_seller       String?
  bid                 Boolean        @default(false)
  bid_price           BigInt?
  bid_buyer           String?
  bid_contract        String?
  bid_block_height    BigInt?
  bid_tx_index        BigInt?
  staked              Boolean        @default(false)
  staking_contract    String?
  staked_owner        String?
  staked_block_height BigInt?
  staked_tx_index     BigInt?
  meta_id             String         @unique @db.Uuid
  updated_at          DateTime       @updatedAt
  list_contract_id    String?        @db.Uuid
  list_contract       SmartContract? @relation(fields: [list_contract_id], references: [id])
  meta                NftMeta        @relation(fields: [meta_id], references: [id])

  @@map("nft_state")
}

model NftMetaBns {
  id        String  @id @default(uuid()) @db.Uuid
  name      String
  namespace String
  meta_id   String  @unique @db.Uuid
  meta      NftMeta @relation(fields: [meta_id], references: [id])

  @@map("nft_meta_bns")
}

model Action {
  id                            String         @id @default(uuid()) @db.Uuid
  action                        ActionName
  bid_attribute                 Json?
  list_price                    Decimal?       @db.Decimal(32, 0)
  seller                        String?
  buyer                         String?
  bid_price                     BigInt?
  block_height                  BigInt
  tx_index                      BigInt
  block_time                    DateTime
  tx_id                         String
  segment                       Boolean        @default(false)
  market_name                   String?
  nonce                         BigInt?
  units                         Int?
  smart_contract_id             String?        @db.Uuid
  marketplace_smart_contract_id String?        @db.Uuid
  nft_meta_id                   String?        @db.Uuid
  collection_id                 String?        @db.Uuid
  collection                    Collection?    @relation(fields: [collection_id], references: [id])
  nft_meta                      NftMeta?       @relation(fields: [nft_meta_id], references: [id])
  smart_contract                SmartContract? @relation(fields: [smart_contract_id], references: [id])
  marketplace_smart_contract    SmartContract? @relation(fields: [marketplace_smart_contract_id], references: [id], name: "marketplace_actions")

  @@map("action")
}

model DiscordServer {
  id                      String                 @id @default(uuid()) @db.Uuid
  server_id               String
  server_name             String
  active                  Boolean                @default(false)
  discord_server_channels DiscordServerChannel[]

  @@unique([server_id])
  @@map("discord_server")
}

model DiscordServerChannel {
  id                String                             @id @default(uuid()) @db.Uuid
  channel_id        String
  name              String
  purpose           DiscordChannelType
  discord_server    DiscordServer                      @relation(fields: [discord_server_id], references: [id])
  discord_server_id String                             @db.Uuid
  collections       CollectionOnDiscordServerChannel[]


  @@map("discord_server_channel")
}

model CollectionOnDiscordServerChannel {
  collection                Collection           @relation(fields: [collection_id], references: [id])
  collection_id             String               @db.Uuid
  discord_server_channel    DiscordServerChannel @relation(fields: [discord_server_channel_id], references: [id])
  discord_server_channel_id String               @db.Uuid

  updated_at DateTime @updatedAt
  created_at DateTime @default(now())

  @@unique([collection_id, discord_server_channel_id])
  @@map("collection_on_discord_server_channel")
}

enum CollectionBidStatus {
  active
  pending
  cancelled
  matched
}

enum BidType {
  collection
  attribute
  solo
}

enum ActionName {
  list
  unlist
  buy
}

enum SmartContractType {
  non_fungible_tokens
  token_series
  marketplace
  staking
  fungible_tokens
  bridge
}

enum DiscordChannelType {
  sales
  listings
  bids
}

enum CollectionScrapeStage {
  getting_tokens
  pinning_folder
  loading_nft_metas
  updating_rarities
  creating_collection_attributes
  pinning_multiple_images
  done
}

enum CollectionScrapeOutcome {
  skipped
  succeeded
  failed
}
